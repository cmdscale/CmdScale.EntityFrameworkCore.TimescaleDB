---
sidebar_position: 0
---

# Version 10.0.1

**Release Date:** February 5, 2026

This release adds automatic refresh policy configuration for continuous aggregates and advanced compression settings for hypertables, providing more control over data management and query performance optimization.

---

## New Features

### Continuous Aggregate Refresh Policies

Continuous aggregates can now be configured with automatic refresh policies that run on a schedule to keep materialized views up-to-date. This feature maps to TimescaleDB's `add_continuous_aggregate_policy()` function and provides fine-grained control over refresh behavior.

#### Fluent API Support

The new `.WithRefreshPolicy()` extension method on `ContinuousAggregateBuilder` configures automatic refresh policies with parameters for time window offsets and execution schedule:

```csharp
builder.IsContinuousAggregate<TradeAggregate, Trade>(
        "trade_aggregate_view", "1 hour", x => x.Timestamp, true, "7 days")
    .AddAggregateFunction(x => x.AveragePrice, x => x.Price, EAggregateFunction.Avg)
    .WithRefreshPolicy(startOffset: "7 days", endOffset: "1 hour", scheduleInterval: "1 hour")
    .WithRefreshNewestFirst(true);
```

The returned `ContinuousAggregatePolicyBuilder` provides additional configuration methods:

- `WithInitialStart(DateTime)` - Set the first scheduled execution time
- `WithIfNotExists(bool)` - Issue notice instead of error if policy exists
- `WithIncludeTieredData(bool)` - Override tiered read settings
- `WithBucketsPerBatch(int)` - Control batch transaction size
- `WithMaxBatchesPerExecution(int)` - Limit batches per run
- `WithRefreshNewestFirst(bool)` - Control refresh direction

#### Data Annotations Support

The new `[ContinuousAggregatePolicy]` attribute provides the same functionality through declarative configuration:

```csharp
[Keyless]
[ContinuousAggregate(MaterializedViewName = "weather_aggregates",
    ParentName = nameof(WeatherData))]
[TimeBucket("1 day", nameof(WeatherData.Time), GroupBy = true)]
[ContinuousAggregatePolicy(
    StartOffset = "30 days",
    EndOffset = "1 day",
    ScheduleInterval = "1 hour",
    RefreshNewestFirst = true)]
public class WeatherAggregate
{
    [Aggregate(EAggregateFunction.Avg, nameof(WeatherData.Temperature))]
    public double AverageTemperature { get; set; }
}
```

All policy configuration options are available as attribute properties, including `InitialStart`, `IfNotExists`, `IncludeTieredData`, `BucketsPerBatch`, `MaxBatchesPerExecution`, and `RefreshNewestFirst`.

### Compression Settings: SegmentBy and OrderBy

Hypertables now support advanced compression configuration to optimize storage and query performance. These settings map to TimescaleDB's `timescaledb.compress_segmentby` and `timescaledb.compress_orderby` parameters.

#### SegmentBy Configuration

SegmentBy specifies columns to group by when compressing data. Columns used for segmentation are not compressed themselves but serve as keys for grouping rows, enabling faster decompression of specific segments during queries.

**Fluent API:**

```csharp
builder.IsHypertable(x => x.Time)
    .WithCompressionSegmentBy(x => x.DeviceId, x => x.TenantId);
```

**Data Annotations:**

```csharp
[Hypertable(nameof(Time), CompressionSegmentBy = new[] { "DeviceId", "TenantId" })]
```

#### OrderBy Configuration

OrderBy specifies the column ordering within compressed segments, which can improve compression ratios and query performance for range scans.

**Fluent API:**

Multiple approaches are supported for specifying ordering:

```csharp
// Using OrderByBuilder
builder.IsHypertable(x => x.Time)
    .WithCompressionOrderBy(
        OrderByBuilder.For<DeviceReading>(x => x.Time).Descending(),
        OrderByBuilder.For<DeviceReading>(x => x.Voltage).Ascending());

// Using OrderBySelector
builder.IsHypertable(x => x.Time)
    .WithCompressionOrderBy(s => new[]
    {
        s.ByDescending(x => x.Time),
        s.ByAscending(x => x.Voltage)
    });

// Using string extensions
builder.IsHypertable(x => x.Time)
    .WithCompressionOrderBy(
        "Time".Descending(),
        "Voltage".Ascending(nullsFirst: true));
```

**Data Annotations:**

SQL syntax is used for ordering specification:

```csharp
[Hypertable(nameof(Time),
    CompressionOrderBy = new[] { "Time DESC", "Voltage ASC NULLS FIRST" })]
```

Both `WithCompressionSegmentBy()` and `WithCompressionOrderBy()` automatically enable compression on the hypertable.

---

## Migration Support

Migrations generated for entities using these new features will include the appropriate TimescaleDB function calls:

- Continuous aggregate refresh policies generate `SELECT add_continuous_aggregate_policy()` statements with all configured parameters
- Compression SegmentBy and OrderBy settings are included in the `ALTER TABLE ... SET` statements for hypertable compression configuration

---

## Breaking Changes

None. This release is fully backward compatible with existing configurations.

---

## Documentation

Complete documentation for these features is available in the Fluent API and Data Annotations sections:

- [Fluent API - Continuous Aggregates - Refresh Policies](../fluent-api/continuous-aggregates#refresh-policies)
- [Data Annotations - Continuous Aggregates - Refresh Policies](../data-annotations/continuous-aggregates#refresh-policies)
- [Fluent API - Hypertables - Compression](../fluent-api/hypertable#compression)
- [Data Annotations - Hypertables - Compression](../data-annotations/hypertable#compression)
